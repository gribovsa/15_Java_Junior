
/*todo
        КОНВЕЙЕРНЫЕ МЕТОДЫ
        Разобравшись с источниками, переходим к следующему этапу.
    Важно не только создать поток, но и уметь с ним работать.
    Здесь мы рассмотрим конвейерные методы, созданные специально для
    обработки данных в потоке.
    Один Stream может иметь сколько угодно конвейерных операций, и
    только одну терминальную.
    До тех пор пока мы не перейдем к рассмотрению терминальных методов,
    будем использовать forEach() в качестве примера.
 */

/**
 * КОНВЕЙЕРНЫЕ МЕТОДЫ
 * filter - конвейерный метод фильтрующий по условию
 * skip - который позволяет пропустить заданное количество первых элементов потока
 * limit - ограничивает обработку указанным количеством первых элементов
 * distinct - пропускает поток без повторов
 * sorted - возвращает поток, отсортированный по возрастанию, также мы можем сами создать компаратор и управлять порядком сортировки
 * map - этот метод проходит по всем элементам и возвращает в поток данные изменённые по логике его лямбда выражения
 * findFirst - выводит первое, удовлетворяющее условию.
 * findAny - возвращает один результат из потока, но не обязательно первый в списке, а первый обработанный.
 * collect - c его помощью мы можем представить данные в виде нужных нам структур данных.
 * collect(Collectors.toList()) - когда данные проходят через конвейер, они собираются в список для дальнейшей работы с ними.
 */


import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Example02 {
    public static void main(String[] args) {
        /*
            Мы подготовили список данных в первой строке и создали поток со встроенным
        фильтром во второй строке. Фильтр проверяет длину строки, которая должна быть
        не менее четырех букв. В терминальном методе мы просто выводим результат в
        консоль. Результат верен только для слов длиной больше четырех символов.
         */
        List<String> list = Arrays.asList("Не", "заменят", "край", "родимый",
                "Никакие", "чудеса!", "Только", "здесь", "всё", "так", "любимо",
                "Реки", "горы", "и", "леса.");
        System.out.println(list + "\n");
        list.stream().filter(n -> n.length() > 4).forEach(n -> System.out.print(n + " "));
        System.out.println("\n");

        /*
            Однако мы написали исходный код не очень аккуратно. Обычно при использовании
        Stream API вызовы методов размещаются на отдельных строках.
         */
        list.stream()
                .filter(n -> n.length() > 4)
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        //Вот так код выглядит лаконичней! Усложню выборку ещё одним фильтром.

        list.stream()
                .filter(n -> n.length() > 4)
                .filter(c -> c.toLowerCase().contains("а"))
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        //Мы добавили одну строку, и все слова, которые не содержат букву “а”, исчезли.


        /*
        Следующим идет конвейерный метод skip, который позволяет пропустить заданное
        количество первых элементов потока.
         */
        list.stream()
                .skip(list.size() / 2)
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");

        /*
        Мы пропустили первую половину данных потока и работать начали только со
        второй! Давайте объединим filter и skip
         */
        list.stream()
                .skip(list.size() / 2)
                .filter(n -> n.length() > 4)
                .filter(n -> n.toLowerCase().contains("а"))
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        //В данном случае в результате будет только слово "леса"!


        /*
        Следующим конвейерным
        методом будет limit. Это skip наоборот! Ограничивает обработку указанным
        количеством первых элементов.
         */
        list.stream()
                .limit(list.size() / 2)
                .filter(n -> n.length() > 4)
                .filter(n -> n.toLowerCase().contains("а"))
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        //Теперь выборка из первой половины.


        /*
        distinct, тут тоже всё просто, он пропускает поток без повторов.
         */
        List<String> newList = Arrays.asList("а", "б", "а", "в", "а", "г", "а", "д");
        newList.stream()
                .distinct()
                .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        //Тут всё просто - никаких параметров, и в результате мы получаем "абвгд", без повторных вхождений!


        /*
        Еще один конвейерный метод называется sorted и возвращает поток,
        отсортированный по возрастанию.
         */
        newList.stream().sorted().forEach(System.out::print);
        System.out.println("\n");


        /*
        Есть более сложный вариант с
        параметром! Крутость его в том, что этот параметр - компаратор, и мы сами можем
        управлять порядком сортировки. Также мы можем сами создать компаратор!
         */
        newList.stream()
                .sorted((s, t1) -> t1.length() - s.length())
                .forEach(System.out::println);
        System.out.println("\n");
        /*
        Здесь я хочу обратить ваше внимание на компаратор. Его поведение определяется
        лямбда-выражением. В данном примере это простейшая однострочная функция, но
        вы не ограничены такой реализацией!
         */
        newList.stream()
                .sorted((s, t1) -> {
                    int tmp = t1.length() - s.length();
                    if (tmp < 0) return 1;
                    else if (tmp > 0) return -1;
                    return 0;
                })
                .forEach(System.out::println);
        System.out.println("\n");

        /*
        Ещё один конвейерный метод и называется он mаp! Этот метод
        проходит по всем элементам и возвращает в поток данные изменённые по логике
        его лямбда выражения. Он, в соответствии c концепцией non-interfering не изменяет
        исходные данные, только данные потока.
         */

        List<String> myList = Arrays.asList("Привет", "Как дела?", "Пропеллер!", "никель");
        myList.stream().map(n -> n.length()).forEach(System.out::println);
        System.out.println("\n");
        //метод выводит длины строк содержащихся в списке


        /*
        Ещё один конвейерный метод findFirst выводит в первое, удовлетворяющее условию.
         */

        List<String> myNewList = Arrays.asList("Привет", "мир", "!", "Я", "родился", "!");
        System.out.println(myNewList.stream().filter(s -> s.length() > 4).findFirst());
        System.out.println("\n");

        /*
        Метод вывел слово "Привет", так как это первое попавшееся в потоке слово
        удовлетворяющее условию. В данном случае метод findFirst() можно было бы
        заменить конструкцией.
         */
        myList.stream()
                .filter(s -> s.length()>4)
                .limit(1)
                .forEach(n -> System.out.print(n));
        System.out.println("\n");
        /*
        Есть
        ещё один похожий метод. findAny(). Он, как и предыдущий, возвращает один
        результат из потока, но не обязательно первый в списке, а первый обработанный.
         */
        System.out.println(myNewList.stream().filter(s -> s.length()>4).findAny());
        System.out.println("\n");

        /*
        Терминальные методы findAny и findFirst возвращают результатом экземпляр
        класса Optional, поэтому и в консоли мы видим "Optional[Привет]". Это не всегда
        удобно. В основном, мы хотим увидеть массивы или списки. Для этого есть другой
        метод, и называется он collect! С его помощью мы можем представить данные в
        виде нужных нам структур данных.
         */
        List<String> srcList = Arrays.asList("Прювет", "мир", "!", "Я", "родился", "!", "Море",
                "Поле");
        List<String> tmpList = myList.stream()
                .sorted((s, t1) -> {
                    int tmp = t1.length() - s.length();
                    if (tmp<0) return 1;
                    else if (tmp>0) return -1;
                    return 0;
                })
                .collect(Collectors.toList());
        System.out.println("\n");

        /*
        В методе collect я использую параметр toList, который является частью
        вспомогательного класса Collectors. Когда данные проходят через конвейер, они
        собираются в список для дальнейшей работы с ними.
         */
    }
}
